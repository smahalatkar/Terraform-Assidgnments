Create the Variables File
In variables.tf create the following variables: app_label, mysql_tier, wordpress_tier, wordpress_version, mysql_password, and mysql_password. Set these default values:
	app_label: wordpress
	mysql_tier: mysql
	wordpress_tier: frontend
	wordpress_version: wordpress_version
	mysql_password: P4sSw0rd0!

Create the Main file
Create a Kubernetes service resource called mysql_service. Within that resource:

Build a metadata block with the following:
	Set the name argument to wordpress-mysql.
	Add a labels block with the app set to the app_label variable.

Make a spec block, and add these two blocks and associated arguments to it:
	A selector block:
		Set the app argument to use the app_label variable.
		Set the tier argument to use the mysql_tier variable.
	A port block:
		Set the port argument to port 3306.
		Set the type argument to NodePort

Create a Kubernetes deployment resource called mysql_deployment. In there:
	Add a metadata block:
		Set the name argument to wordpress-mysql.
		Add a labels block:
			Set an app argument with a value of app_label.
	Add a spec block with the following:
		Set the replicas to 1.
		Add a selector block:
			Inside of that, create a match_labels block with the following arguments:
				Set app to use the app_label variable.
				Set tier to use the mysql_tier variable.
		Create a template block with these other additions:
			A metadata block:
				In here, create a labels block, with these arguments:
					app set to the app_label variable
					tier set to the mysql_tier variable
			A spec block with:
				A container block containing:
					The name argument set to mysql.
					The image argument set to mysql:5.7
					Create an environment variable for MYSQL_ROOT_PASSWORD and set the value to the variable mysql_password.
				Create a port block with the following arguments:
					container_port set to 3306
					name set to mysql

Create a Kubernetes service resource called wordpress_service:
	Add a metadata block:
		Set the name argument to wordpress.
		Add a labels block with the app set to the app_label variable.
	Add a spec block with the following:
		A selector block with these settings:
			Set the app argument to use the app_label variable.
			Set the tier argument to use the mysql_tier variable.
		A port block with these settings:
			Set the port argument to port 80.
			Set the target_port argument to port 80.
			Set the node_port argument to port 8080.
		Set the spec block's type argument to NodePort.

Create a Kubernetes deployment resource called wordpress_deployment:
	Add a metadata block:
		Set the name argument to wordpress.
	Add a spec block with these settings:
		Set the replicas to 1.
		Add a selector block with:
			A match_labels block having the following arguments:
				Set the app argument to use the app_label variable.
				Set the tier argument to use the wordpress_tier variable.
		Add template block containing:
			A metadata block with:
				A labels block having the following arguments:
					app set to the app_label variable
					tier set to the wordpress_tier variable
			A spec block with a container block containing:
				The name argument set to wordpress
				The image argument set to wordpress:
					The tag will be set using the wordpress_version variable with -apache appended to the end of it.
					Create an environment variable for WORDPRESS_DB_HOST and set the value to the variable wordpress-mysql.
					Create another environment variable for WORDPRESS_DB_PASSWORD and set the value to the variable mysql_password.
					Create a port block with the following arguments:
						container_port set to 80
						name set to wordpress


Deploy the infrastructure
	Initialize Terraform.
	Validate the files.
	Deploy the infrastructure.

===========================================================================================================================================================

vi variables.tf

#Define variables
variable "app_label" {
  description = "app label-wordpress"
  default     = "wordpress"
}
variable "mysql_tier" {
  description = "mysql tier desc"
  default     = "mysql"
}
variable "wordpress_tier" {
  description = "wordpress_tier desc."
  default     = "frontend"
}
variable "wordpress_version" {
  description = "wordpress_version desc"
  default     = "wordpress:4.8-apache"
}
variable "mysql_password" {
  description = "mysql_password pass desc."
  default     = "P4sSw0rd0!"
}	

variable "wordpress-mysql" {
  description = "wordpress-mysql desc."
  default     = "wordpress-mysql"
}

vi main.tf

#Creating service as mysql_service
resource "kubernetes_service" "mysql_service" {
  metadata {
    name = "wordpress-mysql"
    labels = {
      app = "${var.app_label}"
    }
  }
  spec {
    selector = {
      app = "${var.app_label}"
      tier = "${var.mysql_tier}"
    }
    port {
      port        = "3306"
    }

    type = "ClusterIP"
  }
}

#Creating deployment as  mysql_deployment
resource "kubernetes_deployment" "mysql_deployment" {
  metadata {
    name = "wordpress-mysql"
     labels = {
      app = "${var.app_label}"
    }
  }

  spec {
    replicas = "1"

    selector  {
      match_labels = {
        app = "${var.app_label}"
        tier = "${var.mysql_tier}"
      }
    }

    template {
      metadata {
        labels = {
          app = "${var.app_label}"
          tier = "${var.mysql_tier}"
        }
      }

      spec {
        container {
          name  = "mysql"
          image = "mysql:5.7"

          env {
              name = "MYSQL_ROOT_PASSWORD"
              value = "${var.mysql_password}"
          }

          port {
            container_port = "3306"
            name = "mysql"
          }
        }
      }
    }
  }
}

#Creating service as wordpress_service
resource "kubernetes_service" "wordpress_service" {
  metadata {
    name = "wordpress"
    labels = {
      app = "${var.app_label}"
    }
  }
  spec {
    selector = {
      app = "${var.app_label}"
      tier = "${var.wordpress_tier}"
    }
    port {
      port        = "80"
      target_port = "80"
      node_port   = "31196"
    }

    type = "NodePort"
  }
}


#Creating deployment as  wordpress_deployment
resource "kubernetes_deployment" "wordpress_deployment" {
  metadata {
    name = "wordpress"
  }

  spec {
    replicas = "1"

    selector  {
      match_labels = {
        app = "${var.app_label}"
        tier = "${var.wordpress_tier}"
      }
    }

    template {
      metadata {
        labels = {
          app = "${var.app_label}"
          tier = "${var.wordpress_tier}"
        }
      }

      spec {
        container {
          name  = "wordpress"
          image = "${var.wordpress_version}"

          env  {
                name = "WORDPRESS_DB_HOST"
                value = "${var.wordpress-mysql}"
          }

         env {
                name = "WORDPRESS_DB_PASSWORD"
                value  = "${var.mysql_password}"
          }

          port {
            container_port = "80"
            name = "wordpress"
          }
        }
      }
    }
  }
}

master $ kubectl get nodes
NAME     STATUS   ROLES    AGE   VERSION
master   Ready    master   51m   v1.14.0
node01   Ready    <none>   50m   v1.14.0

$ terraform init

There are some problems with the configuration, described below.

The Terraform configuration must be valid before initialization so that
Terraform can determine which modules and providers need to be installed.

Error: Error parsing /root/main.tf: At 6:13: Unknown token: 6:13 IDENT var.app_label


master $ vi variables.tf
master $ vi main.tf

$ terraform init
Initializing provider plugins...
- Checking for available provider plugins on https://releases.hashicorp.com...
- Downloading plugin for provider "kubernetes" (1.10.0)...

The following providers do not have any version constraints in configuration,
so the latest version was installed.

To prevent automatic upgrades to new major versions that may contain breaking
changes, it is recommended to add version = "..." constraints to the
corresponding provider blocks in configuration, with the constraint strings
suggested below.

* provider.kubernetes: version = "~> 1.10"

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.

$ terraform validate
Success! The configuration is valid.

$ terraform plan

Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.


------------------------------------------------------------------------

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # kubernetes_deployment.mysql_deployment will be created
  + resource "kubernetes_deployment" "mysql_deployment" {
      + id = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress-mysql"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = 1
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app"  = "wordpress"
                  + "tier" = "mysql"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app"  = "wordpress"
                      + "tier" = "mysql"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + self_link        = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + dns_policy                       = "ClusterFirst"
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                    = "mysql:5.7"
                      + image_pull_policy        = (known after apply)
                      + name                     = "mysql"
                      + stdin                    = false
                      + stdin_once               = false
                      + termination_message_path = "/dev/termination-log"
                      + tty                      = false

                      + env {
                          + name  = "MYSQL_ROOT_PASSWORD"
                          + value = "P4sSw0rd0!"
                        }

                      + port {
                          + container_port = 3306
                          + name           = "mysql"
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }

                          + requests {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }
                        }

                      + volume_mount {
                          + mount_path        = (known after apply)
                          + mount_propagation = (known after apply)
                          + name              = (known after apply)
                          + read_only         = (known after apply)
                          + sub_path          = (known after apply)
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + azure_disk {
                          + caching_mode  = (known after apply)
                          + data_disk_uri = (known after apply)
                          + disk_name     = (known after apply)
                          + fs_type       = (known after apply)
                          + read_only     = (known after apply)
                        }

                      + azure_file {
                          + read_only   = (known after apply)
                          + secret_name = (known after apply)
                          + share_name  = (known after apply)
                        }

                      + ceph_fs {
                          + monitors    = (known after apply)
                          + path        = (known after apply)
                          + read_only   = (known after apply)
                          + secret_file = (known after apply)
                          + user        = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + cinder {
                          + fs_type   = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + config_map {
                          + default_mode = (known after apply)
                          + name         = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + downward_api {
                          + default_mode = (known after apply)

                          + items {
                              + mode = (known after apply)
                              + path = (known after apply)

                              + field_ref {
                                  + api_version = (known after apply)
                                  + field_path  = (known after apply)
                                }

                              + resource_field_ref {
                                  + container_name = (known after apply)
                                  + quantity       = (known after apply)
                                  + resource       = (known after apply)
                                }
                            }
                        }

                      + empty_dir {
                          + medium = (known after apply)
                        }

                      + fc {
                          + fs_type      = (known after apply)
                          + lun          = (known after apply)
                          + read_only    = (known after apply)
                          + target_ww_ns = (known after apply)
                        }

                      + flex_volume {
                          + driver    = (known after apply)
                          + fs_type   = (known after apply)
                          + options   = (known after apply)
                          + read_only = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + flocker {
                          + dataset_name = (known after apply)
                          + dataset_uuid = (known after apply)
                        }

                      + gce_persistent_disk {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + pd_name   = (known after apply)
                          + read_only = (known after apply)
                        }

                      + git_repo {
                          + directory  = (known after apply)
                          + repository = (known after apply)
                          + revision   = (known after apply)
                        }

                      + glusterfs {
                          + endpoints_name = (known after apply)
                          + path           = (known after apply)
                          + read_only      = (known after apply)
                        }

                      + host_path {
                          + path = (known after apply)
                          + type = (known after apply)
                        }

                      + iscsi {
                          + fs_type         = (known after apply)
                          + iqn             = (known after apply)
                          + iscsi_interface = (known after apply)
                          + lun             = (known after apply)
                          + read_only       = (known after apply)
                          + target_portal   = (known after apply)
                        }

                      + local {
                          + path = (known after apply)
                        }

                      + nfs {
                          + path      = (known after apply)
                          + read_only = (known after apply)
                          + server    = (known after apply)
                        }

                      + persistent_volume_claim {
                          + claim_name = (known after apply)
                          + read_only  = (known after apply)
                        }

                      + photon_persistent_disk {
                          + fs_type = (known after apply)
                          + pd_id   = (known after apply)
                        }

                      + quobyte {
                          + group     = (known after apply)
                          + read_only = (known after apply)
                          + registry  = (known after apply)
                          + user      = (known after apply)
                          + volume    = (known after apply)
                        }

                      + rbd {
                          + ceph_monitors = (known after apply)
                          + fs_type       = (known after apply)
                          + keyring       = (known after apply)
                          + rados_user    = (known after apply)
                          + rbd_image     = (known after apply)
                          + rbd_pool      = (known after apply)
                          + read_only     = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + secret {
                          + default_mode = (known after apply)
                          + optional     = (known after apply)
                          + secret_name  = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + vsphere_volume {
                          + fs_type     = (known after apply)
                          + volume_path = (known after apply)
                        }
                    }
                }
            }
        }
    }

  # kubernetes_deployment.wordpress_deployment will be created
  + resource "kubernetes_deployment" "wordpress_deployment" {
      + id = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + name             = "wordpress"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + min_ready_seconds         = 0
          + paused                    = false
          + progress_deadline_seconds = 600
          + replicas                  = 1
          + revision_history_limit    = 10

          + selector {
              + match_labels = {
                  + "app"  = "wordpress"
                  + "tier" = "frontend"
                }
            }

          + strategy {
              + type = (known after apply)

              + rolling_update {
                  + max_surge       = (known after apply)
                  + max_unavailable = (known after apply)
                }
            }

          + template {
              + metadata {
                  + generation       = (known after apply)
                  + labels           = {
                      + "app"  = "wordpress"
                      + "tier" = "frontend"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + self_link        = (known after apply)
                  + uid              = (known after apply)
                }

              + spec {
                  + dns_policy                       = "ClusterFirst"
                  + host_ipc                         = false
                  + host_network                     = false
                  + host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  + restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                  + share_process_namespace          = false
                  + termination_grace_period_seconds = 30

                  + container {
                      + image                    = "wordpress:latest"
                      + image_pull_policy        = (known after apply)
                      + name                     = "wordpress"
                      + stdin                    = false
                      + stdin_once               = false
                      + termination_message_path = "/dev/termination-log"
                      + tty                      = false

                      + env {
                          + name  = "WORDPRESS_DB_HOST"
                          + value = "wordpress-mysql"
                        }
                      + env {
                          + name  = "WORDPRESS_DB_PASSWORD"
                          + value = "P4sSw0rd0!"
                        }

                      + port {
                          + container_port = 80
                          + name           = "wordpress"
                          + protocol       = "TCP"
                        }

                      + resources {
                          + limits {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }

                          + requests {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }
                        }

                      + volume_mount {
                          + mount_path        = (known after apply)
                          + mount_propagation = (known after apply)
                          + name              = (known after apply)
                          + read_only         = (known after apply)
                          + sub_path          = (known after apply)
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + azure_disk {
                          + caching_mode  = (known after apply)
                          + data_disk_uri = (known after apply)
                          + disk_name     = (known after apply)
                          + fs_type       = (known after apply)
                          + read_only     = (known after apply)
                        }

                      + azure_file {
                          + read_only   = (known after apply)
                          + secret_name = (known after apply)
                          + share_name  = (known after apply)
                        }

                      + ceph_fs {
                          + monitors    = (known after apply)
                          + path        = (known after apply)
                          + read_only   = (known after apply)
                          + secret_file = (known after apply)
                          + user        = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + cinder {
                          + fs_type   = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }

                      + config_map {
                          + default_mode = (known after apply)
                          + name         = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + downward_api {
                          + default_mode = (known after apply)

                          + items {
                              + mode = (known after apply)
                              + path = (known after apply)

                              + field_ref {
                                  + api_version = (known after apply)
                                  + field_path  = (known after apply)
                                }

                              + resource_field_ref {
                                  + container_name = (known after apply)
                                  + quantity       = (known after apply)
                                  + resource       = (known after apply)
                                }
                            }
                        }

                      + empty_dir {
                          + medium = (known after apply)
                        }

                      + fc {
                          + fs_type      = (known after apply)
                          + lun          = (known after apply)
                          + read_only    = (known after apply)
                          + target_ww_ns = (known after apply)
                        }

                      + flex_volume {
                          + driver    = (known after apply)
                          + fs_type   = (known after apply)
                          + options   = (known after apply)
                          + read_only = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + flocker {
                          + dataset_name = (known after apply)
                          + dataset_uuid = (known after apply)
                        }

                      + gce_persistent_disk {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + pd_name   = (known after apply)
                          + read_only = (known after apply)
                        }

                      + git_repo {
                          + directory  = (known after apply)
                          + repository = (known after apply)
                          + revision   = (known after apply)
                        }

                      + glusterfs {
                          + endpoints_name = (known after apply)
                          + path           = (known after apply)
                          + read_only      = (known after apply)
                        }

                      + host_path {
                          + path = (known after apply)
                          + type = (known after apply)
                        }

                      + iscsi {
                          + fs_type         = (known after apply)
                          + iqn             = (known after apply)
                          + iscsi_interface = (known after apply)
                          + lun             = (known after apply)
                          + read_only       = (known after apply)
                          + target_portal   = (known after apply)
                        }

                      + local {
                          + path = (known after apply)
                        }

                      + nfs {
                          + path      = (known after apply)
                          + read_only = (known after apply)
                          + server    = (known after apply)
                        }

                      + persistent_volume_claim {
                          + claim_name = (known after apply)
                          + read_only  = (known after apply)
                        }

                      + photon_persistent_disk {
                          + fs_type = (known after apply)
                          + pd_id   = (known after apply)
                        }

                      + quobyte {
                          + group     = (known after apply)
                          + read_only = (known after apply)
                          + registry  = (known after apply)
                          + user      = (known after apply)
                          + volume    = (known after apply)
                        }

                      + rbd {
                          + ceph_monitors = (known after apply)
                          + fs_type       = (known after apply)
                          + keyring       = (known after apply)
                          + rados_user    = (known after apply)
                          + rbd_image     = (known after apply)
                          + rbd_pool      = (known after apply)
                          + read_only     = (known after apply)

                          + secret_ref {
                              + name = (known after apply)
                            }
                        }

                      + secret {
                          + default_mode = (known after apply)
                          + optional     = (known after apply)
                          + secret_name  = (known after apply)

                          + items {
                              + key  = (known after apply)
                              + mode = (known after apply)
                              + path = (known after apply)
                            }
                        }

                      + vsphere_volume {
                          + fs_type     = (known after apply)
                          + volume_path = (known after apply)
                        }
                    }
                }
            }
        }
    }

  # kubernetes_service.mysql_service will be created
  + resource "kubernetes_service" "mysql_service" {
      + id                    = (known after apply)
      + load_balancer_ingress = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress-mysql"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app"  = "wordpress"
              + "tier" = "mysql"
            }
          + session_affinity            = "None"
          + type                        = "NodePort"

          + port {
              + node_port   = (known after apply)
              + port        = 3306
              + protocol    = "TCP"
              + target_port = (known after apply)
            }
        }
    }

  # kubernetes_service.wordpress_service will be created
  + resource "kubernetes_service" "wordpress_service" {
      + id                    = (known after apply)
      + load_balancer_ingress = (known after apply)

      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "wordpress"
            }
          + name             = "wordpress"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }

      + spec {
          + cluster_ip                  = (known after apply)
          + external_traffic_policy     = (known after apply)
          + publish_not_ready_addresses = false
          + selector                    = {
              + "app"  = "wordpress"
              + "tier" = "frontend"
            }
          + session_affinity            = "None"
          + type                        = "NodePort"

          + port {
              + node_port   = 31196
              + port        = 80
              + protocol    = "TCP"
              + target_port = "80"
            }
        }
    }

Plan: 4 to add, 0 to change, 0 to destroy.

------------------------------------------------------------------------

Note: You didn't specify an "-out" parameter to save this plan, so Terraform
can't guarantee that exactly these actions will be performed if
"terraform apply" is subsequently run.

master $ terraform apply -auto-approve
kubernetes_service.wordpress_service: Creating...
kubernetes_service.mysql_service: Creating...
kubernetes_service.mysql_service: Creation complete after 0s [id=default/wordpress-mysql]
kubernetes_service.wordpress_service: Creation complete after 0s [id=default/wordpress]
kubernetes_deployment.mysql_deployment: Creating...
kubernetes_deployment.wordpress_deployment: Creating...
kubernetes_deployment.mysql_deployment: Still creating... [10s elapsed]
kubernetes_deployment.wordpress_deployment: Still creating... [10s elapsed]
kubernetes_deployment.mysql_deployment: Still creating... [20s elapsed]
kubernetes_deployment.wordpress_deployment: Still creating... [20s elapsed]
kubernetes_deployment.wordpress_deployment: Creation complete after 26s [id=default/wordpress]
kubernetes_deployment.mysql_deployment: Still creating... [30s elapsed]
kubernetes_deployment.mysql_deployment: Still creating... [40s elapsed]
kubernetes_deployment.mysql_deployment: Creation complete after 46s [id=default/wordpress-mysql]

Apply complete! Resources: 4 added, 0 changed, 0 destroyed.

master $ kubectl get pods
NAME                               READY   STATUS    RESTARTS   AGE
wordpress-f88975676-pzzcp          1/1     Running   0          76s
wordpress-mysql-7b858c6bdc-9q645   1/1     Running   0          76s

master $ kubectl get deploy
NAME              READY   UP-TO-DATE   AVAILABLE   AGE
wordpress         1/1     1            1           71s
wordpress-mysql   1/1     1            1           71s

master $ kubectl get svc
NAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
kubernetes        ClusterIP   10.96.0.1       <none>        443/TCP        56m
wordpress         NodePort    10.98.23.53     <none>        80:31196/TCP   53s
wordpress-mysql   ClusterIP   10.108.42.114   <none>        3306/TCP       53s

master $ kubectl get pods -o wide
NAME                               READY   STATUS    RESTARTS   AGE     IP          NODE     NOMINATED NODE   READINESS GATES
wordpress-f88975676-pzzcp          1/1     Running   0          5m46s   10.40.0.1   node01   <none>           <none>
wordpress-mysql-7b858c6bdc-9q645   1/1     Running   0          5m46s   10.40.0.2   node01   <none>           <none>
master $ kubectl get deploy -o wide
NAME              READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES             SELECTOR
wordpress         1/1     1            1           5m57s   wordpress    wordpress:latest   app=wordpress,tier=frontend
wordpress-mysql   1/1     1            1           5m57s   mysql        mysql:5.7          app=wordpress,tier=mysql
master $ kubectl get svc -o wide
NAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE     SELECTOR
kubernetes        ClusterIP   10.96.0.1       <none>        443/TCP          23m     <none>
wordpress         NodePort    10.97.150.153   <none>        80:31196/TCP     6m11s   app=wordpress,tier=frontend
wordpress-mysql   NodePort    10.102.204.64   <none>        3306/TCP         6m11s   app=wordpress,tier=mysql